COMMAND PATTERN
===============


* 커맨드 패턴은 Command와 Receiver, Invoker, Client 클래스로 구성된다.
    * Command 객체는 Receiver 객체에 대해 알고 있으며 Receiver 객체의 함수를 호출한다.
    * Receiver 함수의 인자는 Command 객체에 저장돼 있다.
    * Invoker는 명령을 수행한다.
    * Client는 Command 객체를 생성하고 Receiver를 정한다.


* 커맨드 패턴의 목적은 다음과 같다.
    * 요청을 객체 속에 캡슐화한다.
    * 클라이언트의 다양한 요청을 매개변수화한다.
    * 요청을 큐에 저장한다.
    * 객체지향 콜백을 지원한다.

* 커맨드 패턴은 다음과 같은 상황에 적합하다.
    * 수행할 명령에 따라 객체를 변수화할 때
    * 요청을 큐에 저장하고 각기 다른 시점에 수행해야 하는 경우
    * 작은 단위의 연산을 기반으로 하는 상위 연산을 만들 때


----

세부적인 객체 정의
    1. Command: 연산을 수행할 인터페이스를 정의한다.
    2. ConcreteCommand: Receiver 객체와 연산 간 바인딩을 정의한다.
    3. Client: ConcreteCommand 객체를 생성하고 Receiver를 설정한다.
    4. Invoker: ConcreteCommand에 수행을 요청한다.
    5. Receiver: 요청에 관련된 연산을 관리한다.

.. Important:: 전체적인 흐름은 단순하다. 클라이언트는 특정 연산을 요청하고 Invoker는 요청을 받아 캡슐화해 큐에 넣는다.
    ConcreteCommand 클래스는 이 요청을 책임지고 Receiver에 수행을 맡긴다.

----

커맨드패턴의 장/단점

* 장점
    1. 작업을 요청하는 클래스와 실제 작업을 수행하는 클래스를 분리한다.
    2. 큐에 커맨드를 순서대로 저장한다.
    3. 기존 코드를 수정하지 않고 새로운 커맨드를 쉽게 추가할 수 있다.
    4. 커맨드 패턴으로 롤백 시스템을 구현할 수 있다. 앞서 예로 들었던 인스톨 위저드에 롤백 메소드를 쉽게 추가할 수 있다.

* 단점
    1. 클래스와 객체가 많다. 개발자는 신중하게 클래스를 작성해야 한다.
    2. 모든 작업이 독립적인 ConcreteCommand 클래스이므로 구현 및 유지보수해야 하는 클래스가 많다.